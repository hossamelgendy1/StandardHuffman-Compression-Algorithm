package standard_huffman;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Scanner;

public class StandardHuffman {

	static HashMap<Character, String> dictionary; //compression dictionary

	// recursive function to create the
	// huffman-code through the tree traversal.
	// Here s is the huffman - code generated.
	public static void createDictionary(HuffmanNode root, String s) {

		// base case; if the left and right are null
		// then its a leaf node and we add
		// the code s generated by traversing the tree to dictionary.
		if (root.left == null && root.right == null) {

			// c is the character in the node
			dictionary.put(root.c, s);
			return;
		}

		// if we go to left then add "0" to the code.
		// if we go to the right add"1" to the code.
		// recursive calls for left and
		// right sub-tree of the generated tree.
		createDictionary(root.left, s + "0");
		createDictionary(root.right, s + "1");
	}

	public static void huffmanEncode(String fileName) throws IOException {
		dictionary = new HashMap<Character, String>();
		Scanner s = new Scanner(System.in);

		File file = new File(System.getProperty("user.home") + "/Desktop/" + fileName);
		Scanner fileScanner = new Scanner(file);
		String fileContent = "";
		while (fileScanner.hasNextLine()) {
			fileContent = fileContent.concat(fileScanner.nextLine());
		}
		ArrayList<Character> charArray = new ArrayList<Character>();
		ArrayList<Integer> charfreq = new ArrayList<Integer>();
		boolean exists;
		for (int i = 0; i < fileContent.length(); i++) {
			exists = false;
			for (int j = 0; j < charArray.size(); j++) {
				if (fileContent.charAt(i) == charArray.get(j)) {
					exists = true;
					charfreq.set(j, charfreq.get(j) + 1);
					break;
				}
			}
			if (!exists) {
				charArray.add(fileContent.charAt(i));
				charfreq.add(1);
			}
		}
		// number of characters.
		int n = charArray.size();
		
		//showing characters count in console.
		System.out.println("Characters count:");
		for (int i = 0; i < n; i++) {
			System.out.println(charArray.get(i) + ": " + charfreq.get(i));
		}

		// creating a priority queue q.
		// makes a min-priority queue(min-heap).
		PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {

			// creating a Huffman node object
			// and add it to the priority queue.
			HuffmanNode hn = new HuffmanNode();

			hn.c = charArray.get(i);
			hn.frequency = charfreq.get(i);

			hn.left = null;
			hn.right = null;

			// add functions adds the huffman node to the queue.
			q.add(hn);
		}

		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum value
		// from the heap each time until
		// its size reduces to 1, extract until
		// all the nodes are extracted.
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.peek();
			q.poll();

			// second min extract.
			HuffmanNode y = q.peek();
			q.poll();

			// new node f which is equal
			HuffmanNode f = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			f.frequency = x.frequency + y.frequency;
			f.c = '-';

			// first extracted node as left child.
			f.left = x;

			// second extracted node as the right child.
			f.right = y;

			// marking the f node as the root node.
			root = f;

			// add this node to the priority-queue.
			q.add(f);
		}

		// generate the codes by traversing the tree
		createDictionary(root, "");

		String dictionaryContent = "";
		for (int i = 0; i < charArray.size(); i++) {
			dictionaryContent += charArray.get(i).toString() + ' ' + dictionary.get(charArray.get(i)) + ',';
		}

		FileWriter writer = new FileWriter(System.getProperty("user.home") + "/Desktop/dictionary.txt");
		writer.write(dictionaryContent);
		writer.close();

		String CompressedStr = "";
		for (int i = 0; i < fileContent.length(); i++) {
			CompressedStr += dictionary.get(fileContent.charAt(i));
		}

		writer = new FileWriter(System.getProperty("user.home") + "/Desktop/Compressed.txt");
		writer.write(CompressedStr);
		writer.close();

		double compressionRatio = (fileContent.length() * 8.0) / CompressedStr.length();
		System.out.println("compression ratio = " + compressionRatio);
	}

	public static void huffmanDecode(String dictionaryFileName, String compressedFileName) throws IOException {
		HashMap<String, Character> dictionary2 = new HashMap<String, Character>();//decompression dictionary
		Scanner s = new Scanner(System.in);

		File file = new File(System.getProperty("user.home") + "/Desktop/" + dictionaryFileName);
		Scanner fileScanner = new Scanner(file);
		String dictionaryContent = "";
		while (fileScanner.hasNextLine()) {
			dictionaryContent = dictionaryContent.concat(fileScanner.nextLine());
		}

		file = new File(System.getProperty("user.home") + "/Desktop/" + compressedFileName);
		fileScanner = new Scanner(file);
		String compressedCode = "";
		while (fileScanner.hasNextLine()) {
			compressedCode = compressedCode.concat(fileScanner.nextLine());
		}

		int startIndex = 0;
		for (int i = 0; i < dictionaryContent.length(); i++) {
			if (dictionaryContent.charAt(i) == ',') {
				dictionary2.put(dictionaryContent.substring(startIndex + 2, i), dictionaryContent.charAt(startIndex));
				startIndex = i + 1;
			}
		}

		String decodedStr = "";
		for (int i = 0; i < compressedCode.length(); i++) {
			for (int j = 1; j <= compressedCode.length() - i; j++) {
				String sub = compressedCode.substring(i, i + j);
				if (dictionary2.containsKey(sub)) {
					decodedStr += dictionary2.get(sub);
					i += sub.length() - 1;
					break;
				}
			}
		}
		
		FileWriter writer = new FileWriter(System.getProperty("user.home") + "/Desktop/Decoded.txt");
		writer.write(decodedStr);
		writer.close();
	}

	// main function
	public static void main(String[] args) throws IOException {
		huffmanEncode("huff.txt");
		huffmanDecode("dictionary.txt", "Compressed.txt");
	}

}